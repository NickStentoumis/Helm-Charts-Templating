# Helm Chart Refactoring Tool

A Python-based tool for refactoring Helm charts generated by helmify. The tool analyzes microservice deployments to extract common patterns, generates reusable base templates, and creates simplified service files with significant reduction in code duplication.

## Overview

When using helmify to convert Kubernetes manifests to Helm charts, each microservice typically results in 100-150 lines of YAML with substantial duplication across services. This tool addresses that by:

1. Analyzing all services to identify common deployment patterns
2. Generating comprehensive base templates with conditional rendering
3. Creating simplified service files that reference the base templates
4. Restructuring values.yaml to support the new template architecture
5. Extracting and injecting probe configurations from deployment manifests

The result is a refactored Helm chart where each service file is reduced to approximately 5-10 lines, with all common patterns centralized in reusable templates.

## Features

### Dynamic Template Generation
- Analyzes all services in the input to detect which Kubernetes features are used
- Generates base templates that include only the features actually present in your services
- Supports 20+ Kubernetes deployment features including replicas, strategies, probes, resources, volumes, security contexts, and more

### Intelligent Probe Extraction
- Extracts liveness, readiness, and startup probe configurations from deployment YAML
- Handles Helm template syntax that prevents standard YAML parsing
- Injects extracted probes into values.yaml for centralized configuration management

### Values Transformation
- Restructures values.yaml to support multi-container pods
- Adds container wrapper for cleaner organization
- Preserves all existing configurations while enhancing structure

### Code Reduction
- Typical reduction from 100-150 lines per service to 5-10 lines
- 95%+ reduction in deployment and service YAML
- ServiceAccounts and other resources preserved as-is where appropriate

## Architecture

### Components

**parsers/helmify_parser.py**
- Reads and organizes helmify output
- Splits multi-document YAML files
- Groups resources by service
- Preserves original YAML content without modification

**generators/template_builder.py**
- Analyzes all services to detect features
- Generates comprehensive base templates with conditional blocks
- Creates `_helpers-microservice.yaml` with deployment and service templates

**generators/smart_parameterizer.py**
- Detects which Kubernetes features each deployment uses
- Parameterizes service-specific references
- Converts service names to template variables

**utils/probe_extractor.py**
- Extracts probe configurations from deployment YAML
- Handles YAML containing Helm template syntax
- Supports grpc, httpGet, tcpSocket, and exec probe types

**generators/values_transformer.py**
- Restructures values.yaml with containers wrapper
- Injects extracted probe configurations
- Adds serviceAccountName flags where needed

**generators/service_file_generator.py**
- Creates refactored service files using template includes
- Preserves ServiceAccounts and other non-templated resources
- Generates final output with document separators

**models/resource.py**
- Data structures for service resources and chart metadata
- Stores complete original YAML per resource type

## How It Works

### Input Structure
```
helmify-output/
├── Chart.yaml
├── values.yaml
├── _helpers.tpl
└── templates/
    ├── adservice.yaml        (120+ lines)
    ├── frontend.yaml         (150+ lines)
    └── cartservice.yaml      (140+ lines)
```

### Process Flow

1. **Parse Input**: Read all YAML files and organize resources by service
2. **Feature Detection**: Analyze deployments to identify used Kubernetes features
3. **Template Generation**: Create base templates with conditional blocks for detected features
4. **Service File Generation**: Generate simplified service files with template includes
5. **Values Transformation**: Restructure values.yaml and inject probe configurations
6. **File Copying**: Copy Chart.yaml and original helpers

### Output Structure
```
refactored-chart/
├── Chart.yaml
├── values.yaml               (transformed with probes)
├── _helpers.tpl              (original)
└── templates/
    ├── _helpers-microservice.yaml  (base templates)
    ├── adservice.yaml             (5 lines)
    ├── frontend.yaml              (5 lines)
    └── cartservice.yaml           (5 lines)
```

## Installation

### Requirements
- Python 3.7 or higher
- PyYAML

### Setup
```bash
# Clone the repository
git clone <repository-url>
cd helm-refactoring-tool

# Install dependencies
pip install pyyaml --break-system-packages

# Verify installation
python main.py --help
```

## Usage

### Basic Usage
```bash
python main.py <input-directory> <output-directory>
```

### Command-Line Options

```
positional arguments:
  input_dir              Input directory containing helmify output
  output_dir             Output directory for refactored chart

optional arguments:
  -h, --help             Show help message and exit
  -v, --verbose          Enable verbose output
  --validate             Validate generated templates with helm
  --dry-run              Show what would be done without writing files
  --no-transform-values  Do not transform values.yaml structure
```

### Examples

**Basic refactoring:**
```bash
python main.py ./helmify-output ./refactored-chart
```

**With validation:**
```bash
python main.py ./helmify-output ./refactored-chart --validate
```

**Dry run (preview without writing files):**
```bash
python main.py ./helmify-output ./refactored-chart --dry-run
```

**Verbose output:**
```bash
python main.py ./helmify-output ./refactored-chart --verbose
```

## Generated Template Structure

### Base Template Pattern

The tool generates `_helpers-microservice.yaml` containing two main templates:

**microservice.deployment.helmify**
```yaml
{{- define "microservice.deployment.helmify" -}}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "helm.fullname" .root }}-{{ .serviceName }}
spec:
  # Conditional blocks for detected features
  {{- if .Values.replicas }}
  replicas: {{ .Values.replicas }}
  {{- end }}
  
  template:
    spec:
      containers:
      {{- range $containerName, $container := .Values.containers }}
      - name: {{ $containerName }}
        image: {{ $container.image.repository }}:{{ $container.image.tag }}
        
        {{- with $container.livenessProbe }}
        livenessProbe:
          {{- toYaml . | nindent 10 }}
        {{- end }}
        # ... additional conditional blocks
      {{- end }}
{{- end }}
```

**microservice.service.helmify**
```yaml
{{- define "microservice.service.helmify" -}}
apiVersion: v1
kind: Service
metadata:
  name: {{ include "helm.fullname" .root }}-{{ .serviceName }}
spec:
  type: {{ .Values.type | default "ClusterIP" }}
  selector:
    app: {{ .serviceName }}
  ports:
  {{- range .Values.ports }}
  - name: {{ .name }}
    port: {{ .port }}
    targetPort: {{ .targetPort | default .port }}
  {{- end }}
{{- end }}
```

### Refactored Service File

Each service file becomes:
```yaml
{{- include "microservice.deployment.helmify" (dict "Values" .Values.adservice "root" . "serviceName" "adservice") }}
---
{{- include "microservice.service.helmify" (dict "Values" .Values.adservice "root" . "serviceName" "adservice") }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ include "helm.fullname" . }}-adservice
  # ... ServiceAccount preserved as-is
```

## Values.yaml Transformation

### Before Transformation
```yaml
adservice:
  server:
    image:
      repository: adservice
      tag: latest
    env:
      port: "9555"
    resources:
      limits:
        cpu: 300m
  ports:
    - name: grpc
      port: 9555
```

### After Transformation
```yaml
adservice:
  containers:              # New wrapper
    server:
      image:
        repository: adservice
        tag: latest
      env:
        port: "9555"
      resources:
        limits:
          cpu: 300m
      livenessProbe:       # Injected from deployment
        grpc:
          port: 9555
        initialDelaySeconds: 20
      readinessProbe:      # Injected from deployment
        grpc:
          port: 9555
        periodSeconds: 15
  ports:
    - name: grpc
      port: 9555
  serviceAccountName: true # Flag added
```

## Validation

The tool includes built-in validation using Helm's template rendering:

```bash
python main.py ./helmify-output ./refactored-chart --validate
```

This runs `helm template` on the generated chart to ensure:
- Templates render without errors
- Template syntax is valid
- Context references are correct
- All includes resolve properly

## Design Principles

### No Hardcoded Values
All configuration comes from values.yaml. The base templates contain no hardcoded values, ensuring full customization capability.

### Conditional Rendering
The tool uses Helm's conditional blocks (`{{- with }}`, `{{- if }}`) to render only the fields that exist in each service's values.yaml configuration.

### Minimal Modification
Original content is preserved wherever possible. Only Deployments and Services are converted to template includes. ServiceAccounts and other resources remain as-is.

### Feature Detection
Rather than including all possible Kubernetes features, the tool detects which features are actually used in your services and generates templates accordingly.

## Troubleshooting

### Common Issues

**Issue: "No services found"**
- Ensure input directory contains YAML files from helmify
- Check that YAML files contain valid Kubernetes resources

**Issue: "helm command not found" during validation**
- Install Helm: https://helm.sh/docs/intro/install/
- Validation is optional; skip with no `--validate` flag

**Issue: Probe extraction fails**
- Check that deployment YAML contains valid probe configurations
- Tool handles most Helm template syntax automatically

**Issue: Template rendering fails**
- Run with `--validate` to get specific error messages
- Check that values.yaml structure matches expected format
- Ensure Chart.yaml and _helpers.tpl were copied correctly

## Technical Details

### Context Structure

The tool passes context to base templates using Helm's dict function:
```yaml
(dict 
  "Values" .Values.servicename    # Service-specific configuration
  "root" .                         # Root context for Chart and global values
  "serviceName" "servicename"      # Service name as string
)
```

This allows templates to access:
- Service values: `.Values.containers`
- Root context: `.root.Chart.AppVersion`
- Service name: `{{ .serviceName }}`

### Probe Extraction

The probe extractor handles the challenge of extracting structured data from YAML containing Helm template syntax:

1. Uses indentation-based parsing to identify probe blocks
2. Falls back to manual parsing when template syntax prevents YAML parsing
3. Extracts all probe types: grpc, httpGet, tcpSocket, exec
4. Captures all timing parameters: initialDelaySeconds, periodSeconds, etc.

### Template Loading

Helm automatically loads all files in the `templates/` directory and makes defined templates globally available. The underscore prefix on `_helpers-microservice.yaml` indicates it contains template definitions only and should not be rendered as a Kubernetes resource.

## Output Statistics

Typical results for a microservice application with 10 services:

- Original total lines: 1,200-1,500
- Refactored total lines: 150-200
- Reduction: 85-90%
- Base template features detected: 12-18
- Services processed: 10
- Files generated: 13 (10 service files + 1 base template + 2 supporting files)

## Next Steps After Refactoring

1. Review generated files in output directory
2. Validate with Helm:
   ```bash
   helm template test-release ./refactored-chart
   ```
3. Test in development environment:
   ```bash
   helm install my-release ./refactored-chart --dry-run --debug
   ```
4. Deploy when satisfied:
   ```bash
   helm install my-release ./refactored-chart
   ```

## License

[Your License Here]

## Contributing

[Contributing guidelines if applicable]

## Support

[Support information if applicable]
