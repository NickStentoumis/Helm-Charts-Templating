# main.py
#!/usr/bin/env python3
"""
Helm Template Refactoring Tool

This tool takes Helm templates generated by helmify and refactors them to reduce
code duplication by creating base templates and converting service-specific files
to use these base templates.
"""

import argparse
import sys
from pathlib import Path
from typing import List, Dict, Any
import logging

from parsers import DeploymentParser, ServiceParser
from extractors import PatternExtractor
from generators import BaseTemplateGenerator, RefactoredTemplateGenerator
from utils import YamlUtils
from models import KubernetesResource


class HelmTemplateRefactorer:
    """Main class for refactoring Helm templates"""
    
    def __init__(self, input_dir: Path, output_dir: Path):
        self.input_dir = input_dir
        self.output_dir = output_dir
        self.parsers = {
            'deployment': DeploymentParser(),
            'service': ServiceParser(),
            # 'serviceaccount': ServiceAccountParser()
        }
        self.resources: List[KubernetesResource] = []
        self.services: List[str] = []
        
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
    
    def run(self):
        """Execute the refactoring process"""
        self.logger.info(f"Starting Helm template refactoring")
        self.logger.info(f"Input directory: {self.input_dir}")
        self.logger.info(f"Output directory: {self.output_dir}")
        
        # Step 1: Parse all YAML files
        self.logger.info("Step 1: Parsing YAML files...")
        self._parse_yaml_files()
        
        # Step 2: Extract patterns
        self.logger.info("Step 2: Extracting common patterns...")
        patterns = self._extract_patterns()
        
        # Step 3: Generate base templates
        self.logger.info("Step 3: Generating base templates...")
        base_templates = self._generate_base_templates(patterns)
        
        # Step 4: Generate refactored templates
        self.logger.info("Step 4: Generating refactored templates...")
        self._generate_refactored_templates(base_templates)
        
        # Step 5: Copy other necessary files
        self.logger.info("Step 5: Copying additional files...")
        self._copy_additional_files()
        
        self.logger.info("Refactoring complete!")
        self._print_summary()
    
    def _parse_yaml_files(self):
        """Parse all YAML files in the input directory"""
        yaml_files = list(self.input_dir.glob('*.yaml'))
        
        for file_path in yaml_files:
            self.logger.debug(f"Parsing {file_path.name}")
            
            # Extract service name from filename
            service_name = YamlUtils.extract_service_name(file_path.name)
            if service_name not in ['kustomization', 'Chart']:
                self.services.append(service_name)
            
            try:
                with open(file_path, 'r') as f:
                    content = YamlUtils.fix_yaml_formatting(f.read())
                
                # Try each parser
                for parser_type, parser in self.parsers.items():
                    resources = parser.parse(content)
                    self.resources.extend(resources)
                    if resources:
                        self.logger.debug(f"  Found {len(resources)} {parser_type}(s)")
                        
            except Exception as e:
                self.logger.error(f"Error parsing {file_path.name}: {e}")
        
        self.logger.info(f"Parsed {len(self.resources)} resources from {len(yaml_files)} files")
        self.logger.info(f"Found services: {', '.join(self.services)}")
    
    def _extract_patterns(self) -> Dict[str, Any]:
        """Extract common patterns from parsed resources"""
        extractor = PatternExtractor()
        extractor.add_resources(self.resources)
        patterns = extractor.extract_patterns()
        
        self.logger.info(f"Extracted patterns:")
        self.logger.info(f"  - Deployment patterns: {len(patterns.get('deployment_patterns', {}))} types")
        self.logger.info(f"  - Service patterns: {len(patterns.get('service_patterns', {}))} types")
        self.logger.info(f"  - Cross-resource patterns: {len(patterns.get('cross_resource_patterns', {}))} types")
        
        return patterns
    
    def _generate_base_templates(self, patterns: Dict[str, Any]) -> Dict[str, str]:
        """Generate base templates"""
        generator = BaseTemplateGenerator(patterns)
        base_templates = generator.generate_all_templates()
        
        # Save base templates
        generator.save_templates(self.output_dir)
        
        self.logger.info(f"Generated {len(base_templates)} base templates")
        
        return base_templates
    
    def _generate_refactored_templates(self, base_templates: Dict[str, str]):
        """Generate refactored service templates"""
        generator = RefactoredTemplateGenerator(base_templates)
        generator.save_refactored_templates(self.output_dir, self.services)
        
        self.logger.info(f"Generated {len(self.services)} refactored service templates")
    
    def _copy_additional_files(self):
        """Copy additional files like values.yaml and Chart.yaml"""
        files_to_copy = ['values.yaml', 'Chart.yaml']
        
        for file_name in files_to_copy:
            source = self.input_dir / file_name
            if source.exists():
                dest = self.output_dir / file_name
                dest.parent.mkdir(parents=True, exist_ok=True)
                
                with open(source, 'r') as f:
                    content = f.read()
                with open(dest, 'w') as f:
                    f.write(content)
                
                self.logger.info(f"  Copied {file_name}")
    
    def _print_summary(self):
        """Print summary of refactoring"""
        print("\n" + "="*60)
        print("REFACTORING SUMMARY")
        print("="*60)
        print(f" Processed {len(self.resources)} Kubernetes resources")
        print(f" Created base templates in {self.output_dir}/templates/_base/")
        print(f" Generated refactored templates for {len(self.services)} services")
        print(f"\nBase templates created:")
        print(f"  - _base/deployment.yaml")
        print(f"  - _base/service.yaml")
        print(f"  - _base/serviceaccount.yaml")
        print(f"  - _helpers-microservice.yaml")
        print(f"\nRefactored service templates:")
        for service in self.services:
            print(f"  - {service}.yaml")
        print(f"\nOutput directory: {self.output_dir}")
        print("="*60)


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Refactor Helm templates generated by helmify to reduce code duplication'
    )
    parser.add_argument(
        'input_dir',
        type=str,
        help='Input directory containing helmify-generated YAML files'
    )
    parser.add_argument(
        'output_dir',
        type=str,
        help='Output directory for refactored templates'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Enable debug logging'
    )
    
    args = parser.parse_args()
    
    # Set logging level
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Validate input directory
    input_dir = Path(args.input_dir)
    if not input_dir.exists() or not input_dir.is_dir():
        print(f"Error: Input directory '{input_dir}' does not exist or is not a directory")
        sys.exit(1)
    
    # Create output directory
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)
    
    # Run refactorer
    refactorer = HelmTemplateRefactorer(input_dir, output_dir)
    
    try:
        refactorer.run()
    except Exception as e:
        print(f"Error during refactoring: {e}")
        if args.debug:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()